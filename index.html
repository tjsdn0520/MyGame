<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Survival Game (Single & Multi)</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        canvas { display: block; }
        
        #ui-layer, #buff-layer, #skill-bar { pointer-events: none; z-index: 10; display: none; position: absolute; }
        #ui-layer { top: 20px; left: 20px; }
        .stat-box { margin-bottom: 5px; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 4px; font-weight: bold; }
        
        #skill-bar { bottom: 30px; left: 50%; transform: translateX(-50%); display: none; gap: 15px; }
        .skill-slot { width: 60px; height: 60px; background: #222; border: 2px solid #555; border-radius: 8px; position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #fff; }
        .skill-cooldown { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0,0,0,0.8); transition: height 0.1s linear; }

        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 200; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .mode-btn { margin: 10px; padding: 15px 30px; font-size: 20px; cursor: pointer; background: #444; color: white; border: 2px solid #00ffcc; border-radius: 10px; }
        .mode-btn:hover { background: #00ffcc; color: black; }
        .hidden { display: none !important; }
        
        .class-container { display: flex; gap: 20px; margin-top: 30px; }
        .class-card { background: #222; border: 2px solid #555; width: 200px; padding: 20px; border-radius: 10px; text-align: center; cursor: pointer; transition: 0.2s; }
        .class-card:hover { transform: scale(1.05); border-color: white; background: #333; }
        .class-card.selected { border-color: #ffd700; background: #442200; }

        #wait-screen { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 300; justify-content: center; align-items: center; flex-direction: column; }
        
        #game-over { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(50,0,0,0.9); z-index: 400; justify-content: center; align-items: center; flex-direction: column; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="stat-box">MODE: <span id="ui-mode" style="color:yellow;">-</span></div>
        <div class="stat-box">HP: <span id="ui-hp" style="color:#ff5555;">100</span></div>
        <div class="stat-box" id="score-box">SCORE: <span id="ui-score">0</span></div>
    </div>
    
    <div id="skill-bar">
        <div class="skill-slot">J<div class="skill-cooldown" id="cd-j"></div></div>
        <div class="skill-slot">K<div class="skill-cooldown" id="cd-k"></div></div>
        <div class="skill-slot">L<div class="skill-cooldown" id="cd-l"></div></div>
    </div>

    <div id="start-screen">
        <h1 style="color:#ffd700;">SURVIVAL ARENA</h1>
        <div id="mode-selection">
            <button class="mode-btn" onclick="selectMode('single')">싱글 플레이 (생존)</button>
            <button class="mode-btn" onclick="selectMode('multi')">멀티 플레이 (1vs1 PvP)</button>
        </div>
        
        <div id="class-selection" class="hidden">
            <h2 id="mode-title">직업을 선택하세요</h2>
            <div class="class-container">
                <div class="class-card" onclick="selectJob('knight')"><h3>기사</h3><p>근접 밸런스</p></div>
                <div class="class-card" onclick="selectJob('shooter')"><h3>슈터</h3><p>원거리 견제</p></div>
                <div class="class-card" onclick="selectJob('mage')"><h3>마법사</h3><p>범위 폭딜</p></div>
            </div>
            <button class="mode-btn" onclick="confirmStart()" style="margin-top:30px;">게임 시작</button>
        </div>
    </div>

    <div id="wait-screen">
        <h1 style="color:white;">상대방을 기다리는 중...</h1>
        <p style="color:#aaa;">접속 대기 중입니다.</p>
    </div>

    <div id="game-over">
        <h1 id="go-title" style="color:red;">GAME OVER</h1>
        <button class="mode-btn" onclick="location.reload()">타이틀로 이동</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;

        // --- 이미지 로드 ---
        const mobImages = {};
        ['mob1', 'mob2', 'mob3'].forEach(name => { const img=new Image(); img.src=`./${name}.png`; mobImages[name]=img; });

        // --- 전역 변수 ---
        let socket; 
        const game = { mode: null, active: false, paused: false, room: null, role: null };
        const keys = {};
        
        // 직업 데이터
        const JOBS = {
            knight: { hp: 200, speed: 3, color: '#00ffcc', range: 100, damage: 20, cd: {j:3000, k:2000, l:10000} },
            shooter: { hp: 120, speed: 4.5, color: '#ffcc00', range: 400, damage: 15, cd: {j:4000, k:2000, l:8000} },
            mage: { hp: 150, speed: 3.5, color: '#aa00ff', range: 200, damage: 30, cd: {j:3000, k:4000, l:15000} }
        };

        // 플레이어 & 상대방
        let player = { x:0, y:0, hp:100, maxHp:100, job:'knight', facing:{x:1,y:0}, skillCD:{j:0,k:0,l:0}, skillMax:{j:0,k:0,l:0} };
        let opponent = { active: false, x:0, y:0, hp:100, maxHp:100, job:'knight', facing:{x:1,y:0} }; // 멀티용 상대
        let enemies = []; // 싱글용 몹
        let projectiles = []; 
        let particles = [];

        let selectedJob = null;
        let lastTime = 0;

        // --- 입력 처리 ---
        window.addEventListener('keydown', e => { 
            if(e.code==='Space') e.preventDefault();
            keys[e.code] = true; 
        });
        window.addEventListener('keyup', e => { 
            keys[e.code] = false;
            if(game.active && !game.paused) {
                if(e.code==='KeyJ') useSkill('j');
                if(e.code==='KeyK') useSkill('k');
                if(e.code==='KeyL') useSkill('l');
                if(e.code==='Space') basicAttack();
            }
        });

        // --- 모드 선택 및 시작 ---
        function selectMode(mode) {
            game.mode = mode;
            document.getElementById('mode-selection').classList.add('hidden');
            document.getElementById('class-selection').classList.remove('hidden');
            document.getElementById('mode-title').innerText = (mode==='single') ? "싱글플레이 직업 선택" : "멀티플레이(PvP) 직업 선택";
        }

        function selectJob(job) {
            selectedJob = job;
            document.querySelectorAll('.class-card').forEach(el => el.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }

        function confirmStart() {
            if(!selectedJob) return alert("직업을 선택해주세요!");
            
            // 플레이어 초기화
            const data = JOBS[selectedJob];
            player.job = selectedJob;
            player.hp = player.maxHp = data.hp;
            player.speed = data.speed;
            player.x = canvas.width/2; player.y = canvas.height/2;
            player.skillMax = {...data.cd};

            if (game.mode === 'single') {
                startSingleGame();
            } else {
                connectMultiplayer();
            }
        }

        function startSingleGame() {
            document.getElementById('start-screen').style.display = 'none';
            setupGameUI();
            game.active = true;
            lastTime = Date.now();
            requestAnimationFrame(gameLoop);
        }

        function connectMultiplayer() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('wait-screen').style.display = 'flex';

            // 소켓 연결
            socket = io();
            
            // 매칭 요청
            socket.emit('join_game', { job: selectedJob });

            socket.on('waiting', () => { console.log("Waiting for opponent..."); });

            socket.on('game_start', (data) => {
                document.getElementById('wait-screen').style.display = 'none';
                game.room = data.room;
                game.role = data.role; // p1 or p2
                
                // 상대방 초기화
                const opData = JOBS[data.opponentJob];
                opponent.active = true;
                opponent.job = data.opponentJob;
                opponent.hp = opponent.maxHp = opData.hp;
                opponent.color = opData.color;
                // 위치 분배
                if(game.role === 'p1') { player.x = 100; opponent.x = canvas.width - 100; }
                else { player.x = canvas.width - 100; opponent.x = 100; }
                player.y = opponent.y = canvas.height/2;

                setupGameUI();
                game.active = true;
                lastTime = Date.now();
                requestAnimationFrame(gameLoop);
            });

            // 상대방 움직임 수신
            socket.on('opponent_update', (data) => {
                if(!opponent.active) return;
                opponent.x = data.x;
                opponent.y = data.y;
                opponent.hp = data.hp;
                opponent.facing = data.facing;
            });

            // 상대방 공격 수신 (이펙트만)
            socket.on('opponent_attack', (data) => {
                // 상대방 위치에서 이펙트/투사체 생성
                handleOpponentAttack(data.type);
            });

            socket.on('opponent_left', () => {
                alert("상대방이 나갔습니다. 승리!");
                location.reload();
            });
        }

        function setupGameUI() {
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('skill-bar').style.display = 'flex';
            document.getElementById('ui-mode').innerText = game.mode.toUpperCase();
            if(game.mode === 'multi') document.getElementById('score-box').style.display = 'none';
        }

        // --- 게임 루프 ---
        function gameLoop() {
            if(!game.active) return;
            const now = Date.now();
            const dt = now - lastTime;
            lastTime = now;

            update(dt);
            draw();
            
            // 멀티플레이어면 내 정보 전송
            if(game.mode === 'multi' && socket) {
                socket.emit('player_update', {
                    room: game.room,
                    x: player.x,
                    y: player.y,
                    hp: player.hp,
                    facing: player.facing
                });
            }

            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            // 1. 플레이어 이동
            let mx=0, my=0;
            if(keys['ArrowUp'] || keys['KeyW']) my-=1;
            if(keys['ArrowDown'] || keys['KeyS']) my+=1;
            if(keys['ArrowLeft'] || keys['KeyA']) mx-=1;
            if(keys['ArrowRight'] || keys['KeyD']) mx+=1;

            if(mx!==0 || my!==0) {
                const len = Math.sqrt(mx*mx+my*my);
                player.x += (mx/len) * player.speed;
                player.y += (my/len) * player.speed;
                player.facing = {x:mx/len, y:my/len};
            }
            player.x = Math.max(20, Math.min(canvas.width-20, player.x));
            player.y = Math.max(20, Math.min(canvas.height-20, player.y));

            // 2. 쿨타임 처리
            for(let k in player.skillCD) {
                if(player.skillCD[k] > 0) {
                    player.skillCD[k] -= dt;
                    document.getElementById(`cd-${k}`).style.height = (player.skillCD[k]/player.skillMax[k])*100 + '%';
                }
            }

            // 3. 싱글플레이 적 생성
            if(game.mode === 'single') {
                if(Math.random() < 0.02) spawnEnemy();
                
                // 적 이동
                enemies.forEach((e, i) => {
                    const dx = player.x - e.x, dy = player.y - e.y;
                    const dist = Math.hypot(dx, dy);
                    e.x += (dx/dist)*e.speed; e.y += (dy/dist)*e.speed;
                    // 플레이어 충돌
                    if(dist < 20 + e.radius) {
                        damagePlayer(5);
                        enemies.splice(i, 1);
                    }
                });
            }

            // 4. 투사체 이동
            for(let i=projectiles.length-1; i>=0; i--) {
                const p = projectiles[i];
                p.x += p.vx; p.y += p.vy;
                p.life -= dt;
                
                let hit = false;

                // 싱글: 적 충돌
                if(game.mode === 'single') {
                    for(let j=enemies.length-1; j>=0; j--) {
                        const e = enemies[j];
                        if(Math.hypot(p.x-e.x, p.y-e.y) < e.radius + p.radius) {
                            enemies.splice(j, 1); hit = true; break;
                        }
                    }
                } 
                // 멀티: 상대방 충돌 (내가 쏜 투사체만 판정)
                else if(game.mode === 'multi' && p.owner === 'me') {
                    if(Math.hypot(p.x-opponent.x, p.y-opponent.y) < 20 + p.radius) {
                        // 상대방에게 맞았다고 알림 X -> 그냥 내 화면에서 이펙트, 실제 체력은 각자 계산은 복잡하므로
                        // 간단하게: 내가 때렸으면 이펙트 띄우고, 체력바는 상대가 보낸 데이터로 갱신됨.
                        // 정확한 동기화를 위해선 서버가 판정해야 하지만, 여기선 클라이언트가 "내가 맞췄어"라고 믿는 방식
                        hit = true;
                    }
                }

                if(hit || p.life <= 0) projectiles.splice(i, 1);
            }

            // 5. 파티클
            particles.forEach((p,i) => {
                p.life -= dt; p.x += p.vx; p.y += p.vy;
                if(p.life<=0) particles.splice(i,1);
            });
        }

        function draw() {
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0,0,canvas.width,canvas.height);
            
            // 싱글 몹
            if(game.mode==='single') {
                enemies.forEach(e => {
                    if(mobImages[e.type] && mobImages[e.type].complete) {
                        ctx.drawImage(mobImages[e.type], e.x-20, e.y-20, 40, 40);
                    } else {
                        ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(e.x,e.y,20,0,7); ctx.fill();
                    }
                });
            }

            // 멀티 상대방
            if(game.mode==='multi' && opponent.active) {
                ctx.fillStyle = opponent.color || 'red';
                ctx.beginPath(); ctx.arc(opponent.x, opponent.y, 20, 0, 7); ctx.fill();
                // 상대 체력바
                ctx.fillStyle = 'red'; ctx.fillRect(opponent.x-20, opponent.y-35, 40, 5);
                ctx.fillStyle = 'lime'; ctx.fillRect(opponent.x-20, opponent.y-35, 40 * (opponent.hp/opponent.maxHp), 5);
                ctx.fillStyle = 'white'; ctx.fillText("Enemy", opponent.x-15, opponent.y-40);
            }

            // 플레이어
            ctx.fillStyle = JOBS[player.job].color;
            ctx.beginPath(); ctx.arc(player.x, player.y, 20, 0, 7); ctx.fill();
            // 눈
            ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(player.x+player.facing.x*10, player.y+player.facing.y*10, 5, 0, 7); ctx.fill();

            // 투사체 & 파티클
            projectiles.forEach(p => { ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,p.radius,0,7); ctx.fill(); });
            particles.forEach(p => { ctx.fillStyle=p.color; ctx.globalAlpha=p.life/500; ctx.beginPath(); ctx.arc(p.x,p.y,3,0,7); ctx.fill(); ctx.globalAlpha=1; });

            // UI 업데이트
            document.getElementById('ui-hp').innerText = Math.floor(player.hp);
        }

        // --- 액션 로직 ---
        function basicAttack() {
            createProjectile(player.x, player.y, Math.atan2(player.facing.y, player.facing.x), 'bullet');
            if(game.mode === 'multi') socket.emit('attack_event', { room: game.room, type: 'basic', x: player.x, y: player.y, angle: Math.atan2(player.facing.y, player.facing.x) });
            
            // 근접 공격 판정 (기사)
            if(player.job === 'knight') {
                checkMeleeHit(100, 20);
            }
        }

        function useSkill(k) {
            if(player.skillCD[k] > 0) return;
            player.skillCD[k] = player.skillMax[k];
            
            // 스킬 시각 효과
            createParticles(player.x, player.y, 'white', 10);
            
            if(game.mode === 'multi') socket.emit('attack_event', { room: game.room, type: 'skill_'+k, job: player.job });

            // 실제 로직 (간단화)
            if(player.job === 'shooter' && k === 'j') { // 산탄
                for(let i=-0.5; i<=0.5; i+=0.5) createProjectile(player.x, player.y, Math.atan2(player.facing.y, player.facing.x)+i, 'bullet');
            }
            // ... 다른 스킬 로직들 (싱글과 동일하게 투사체 생성 등)
        }

        function handleOpponentAttack(type) {
            // 상대방이 공격했을 때 내 화면에 보여줄 것
            if(type === 'basic') {
                // 상대방 위치에서 총알 발사되는 것처럼 보이기
                // (정확한 위치는 서버에서 받아야 하지만 약식으로)
            }
        }

        function createProjectile(x, y, angle, type) {
            projectiles.push({ x:x, y:y, vx:Math.cos(angle)*10, vy:Math.sin(angle)*10, life:1000, radius:5, color:'yellow', owner:'me' });
        }
        
        function createParticles(x, y, c, n) {
            for(let i=0;i<n;i++) particles.push({x:x, y:y, vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5, life:500, color:c});
        }

        function spawnEnemy() {
            const types = ['mob1','mob2','mob3'];
            const t = types[Math.floor(Math.random()*3)];
            enemies.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, type: t, speed: 1 + Math.random(), radius: 20 });
        }

        function damagePlayer(amount) {
            player.hp -= amount;
            createParticles(player.x, player.y, 'red', 5);
            if(player.hp <= 0) {
                game.active = false;
                document.getElementById('game-over').style.display = 'flex';
                if(game.mode === 'multi') socket.disconnect();
            }
        }
        
        // PvP 히트 체크 (간단버전: 내가 공격했을 때 상대방 위치 계산)
        function checkMeleeHit(range, damage) {
            if(game.mode === 'multi' && opponent.active) {
                const dist = Math.hypot(player.x - opponent.x, player.y - opponent.y);
                if(dist < range) {
                    // 원래는 서버에 "내가 때렸음"을 보내고 서버가 체력을 깎아야 함.
                    // 여기서는 시각적 효과만.
                    createParticles(opponent.x, opponent.y, 'orange', 5);
                }
            }
        }

    </script>
</body>
</html>