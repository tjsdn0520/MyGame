<script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;

        // 이미지 로드
        const mobImages = {};
        ['mob1', 'mob2', 'mob3'].forEach(name => { const img=new Image(); img.src=`./${name}.png`; mobImages[name]=img; });

        // --- 전역 변수 ---
        let socket; 
        const game = { mode: null, active: false, paused: false, room: null, role: null };
        const keys = {};
        
        const JOBS = {
            knight: { hp: 200, speed: 3, color: '#00ffcc', range: 100, damage: 20, cd: {j:3000, k:2000, l:10000} },
            shooter: { hp: 120, speed: 4.5, color: '#ffcc00', range: 400, damage: 15, cd: {j:4000, k:2000, l:8000} },
            mage: { hp: 150, speed: 3.5, color: '#aa00ff', range: 200, damage: 30, cd: {j:3000, k:4000, l:15000} }
        };

        let player = { x:0, y:0, hp:100, maxHp:100, job:'knight', facing:{x:1,y:0}, skillCD:{j:0,k:0,l:0}, skillMax:{j:0,k:0,l:0} };
        
        // [수정] 상대방 데이터에 '목표 위치(targetX, targetY)' 추가 (부드러운 이동용)
        let opponent = { active: false, x:0, y:0, targetX:0, targetY:0, hp:100, maxHp:100, job:'knight', facing:{x:1,y:0} };
        
        let enemies = []; 
        let projectiles = []; 
        let particles = [];
        let selectedJob = null;
        let lastTime = 0;
        let updateTimer = 0; // 통신 빈도 조절용

        // --- 입력 처리 ---
        window.addEventListener('keydown', e => { if(e.code==='Space') e.preventDefault(); keys[e.code] = true; });
        window.addEventListener('keyup', e => { 
            keys[e.code] = false;
            if(game.active && !game.paused) {
                if(e.code==='KeyJ') useSkill('j');
                if(e.code==='KeyK') useSkill('k');
                if(e.code==='KeyL') useSkill('l');
                if(e.code==='Space') basicAttack();
            }
        });

        // --- 모드/직업 선택 ---
        function selectMode(mode) {
            game.mode = mode;
            document.getElementById('mode-selection').classList.add('hidden');
            document.getElementById('class-selection').classList.remove('hidden');
            document.getElementById('mode-title').innerText = (mode==='single') ? "싱글플레이" : "멀티플레이(PvP)";
        }
        function selectJob(job) {
            selectedJob = job;
            document.querySelectorAll('.class-card').forEach(el => el.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }
        function confirmStart() {
            if(!selectedJob) return alert("직업을 선택해주세요!");
            const data = JOBS[selectedJob];
            player.job = selectedJob;
            player.hp = player.maxHp = data.hp;
            player.speed = data.speed;
            player.x = canvas.width/2; player.y = canvas.height/2;
            player.skillMax = {...data.cd};
            if (game.mode === 'single') startSingleGame();
            else connectMultiplayer();
        }

        function startSingleGame() {
            document.getElementById('start-screen').style.display = 'none';
            setupGameUI();
            game.active = true;
            lastTime = Date.now();
            requestAnimationFrame(gameLoop);
        }

        function connectMultiplayer() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('wait-screen').style.display = 'flex';

            socket = io();
            socket.emit('join_game', { job: selectedJob });

            socket.on('game_start', (data) => {
                document.getElementById('wait-screen').style.display = 'none';
                game.room = data.room;
                game.role = data.role;
                
                const opData = JOBS[data.opponentJob];
                opponent.active = true;
                opponent.job = data.opponentJob;
                opponent.hp = opponent.maxHp = opData.hp;
                opponent.color = opData.color;
                
                if(game.role === 'p1') { player.x = 100; opponent.x = canvas.width - 100; }
                else { player.x = canvas.width - 100; opponent.x = 100; }
                opponent.targetX = opponent.x; 
                opponent.targetY = opponent.y;
                player.y = opponent.y = canvas.height/2;

                setupGameUI();
                game.active = true;
                lastTime = Date.now();
                requestAnimationFrame(gameLoop);
            });

            // [수정] 상대 위치 수신 (바로 적용하지 않고 target에 저장)
            socket.on('opponent_update', (data) => {
                if(!opponent.active) return;
                opponent.targetX = data.x;
                opponent.targetY = data.y;
                opponent.hp = data.hp; // HP는 바로 동기화
                opponent.facing = data.facing;
            });

            // [수정] 상대 공격 수신 -> 실제 총알 생성
            socket.on('opponent_attack', (data) => {
                handleOpponentAttack(data);
            });

            socket.on('opponent_left', () => { alert("상대방이 나갔습니다. 승리!"); location.reload(); });
        }

        function setupGameUI() {
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('skill-bar').style.display = 'flex';
            document.getElementById('ui-mode').innerText = game.mode.toUpperCase();
            if(game.mode === 'multi') document.getElementById('score-box').style.display = 'none';
        }

        // --- 게임 루프 ---
        function gameLoop() {
            if(!game.active) return;
            const now = Date.now();
            const dt = now - lastTime;
            lastTime = now;

            update(dt);
            draw();
            
            // [최적화] 멀티플레이 정보 전송 (너무 자주 보내지 않게 30ms 제한)
            if(game.mode === 'multi' && socket) {
                updateTimer += dt;
                if(updateTimer > 30) { // 약 30프레임 속도로 전송
                    socket.emit('player_update', {
                        room: game.room,
                        x: player.x,
                        y: player.y,
                        hp: player.hp,
                        facing: player.facing
                    });
                    updateTimer = 0;
                }
            }
            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            // 1. 내 이동
            let mx=0, my=0;
            if(keys['ArrowUp'] || keys['KeyW']) my-=1;
            if(keys['ArrowDown'] || keys['KeyS']) my+=1;
            if(keys['ArrowLeft'] || keys['KeyA']) mx-=1;
            if(keys['ArrowRight'] || keys['KeyD']) mx+=1;

            if(mx!==0 || my!==0) {
                const len = Math.sqrt(mx*mx+my*my);
                player.x += (mx/len) * player.speed;
                player.y += (my/len) * player.speed;
                player.facing = {x:mx/len, y:my/len};
            }
            player.x = Math.max(20, Math.min(canvas.width-20, player.x));
            player.y = Math.max(20, Math.min(canvas.height-20, player.y));

            // [추가] 상대방 부드러운 이동 (보간법: 선형 보간)
            if(game.mode === 'multi' && opponent.active) {
                // 현재 위치와 목표 위치 사이를 10%씩 좁혀나감 (부드럽게 보임)
                opponent.x += (opponent.targetX - opponent.x) * 0.1;
                opponent.y += (opponent.targetY - opponent.y) * 0.1;
            }

            // 2. 쿨타임 처리
            for(let k in player.skillCD) {
                if(player.skillCD[k] > 0) {
                    player.skillCD[k] -= dt;
                    document.getElementById(`cd-${k}`).style.height = (player.skillCD[k]/player.skillMax[k])*100 + '%';
                }
            }

            // 3. 투사체 이동 및 충돌 처리
            for(let i=projectiles.length-1; i>=0; i--) {
                const p = projectiles[i];
                p.x += p.vx; p.y += p.vy;
                p.life -= dt;
                
                let hit = false;

                // [싱글] 적과 충돌
                if(game.mode === 'single') {
                    for(let j=enemies.length-1; j>=0; j--) {
                        const e = enemies[j];
                        if(Math.hypot(p.x-e.x, p.y-e.y) < e.radius + p.radius) {
                            enemies.splice(j, 1); hit = true; break;
                        }
                    }
                } 
                // [멀티] 충돌 처리
                else if(game.mode === 'multi') {
                    // 1) 내가 쏜 것(owner: 'me') -> 상대방 화면은 신경 안 씀 (상대가 스스로 맞았는지 체크할 것임)
                    // 2) 적이 쏜 것(owner: 'enemy') -> 내 몸에 맞았는지 체크
                    if(p.owner === 'enemy') {
                        if(Math.hypot(p.x-player.x, p.y-player.y) < 20 + p.radius) {
                            // 내가 맞았다!
                            damagePlayer(p.damage);
                            hit = true;
                        }
                    }
                }

                if(hit || p.life <= 0) projectiles.splice(i, 1);
            }

            // 4. 싱글 몹 로직 생략 (기존 유지)
            if(game.mode === 'single') { /* 싱글 몹 생성 및 이동 로직... */ }
            
            // 5. 파티클
            particles.forEach((p,i) => {
                p.life -= dt; p.x += p.vx; p.y += p.vy;
                if(p.life<=0) particles.splice(i,1);
            });
        }

        function draw() {
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0,0,canvas.width,canvas.height);
            
            // 멀티 상대방
            if(game.mode==='multi' && opponent.active) {
                ctx.fillStyle = opponent.color || 'red';
                ctx.beginPath(); ctx.arc(opponent.x, opponent.y, 20, 0, 7); ctx.fill();
                // 상대 체력바
                ctx.fillStyle = 'red'; ctx.fillRect(opponent.x-20, opponent.y-35, 40, 5);
                ctx.fillStyle = 'lime'; ctx.fillRect(opponent.x-20, opponent.y-35, 40 * (opponent.hp/opponent.maxHp), 5);
                ctx.fillStyle = 'white'; ctx.fillText("Enemy", opponent.x-15, opponent.y-40);
            }

            // 플레이어
            ctx.fillStyle = JOBS[player.job].color;
            ctx.beginPath(); ctx.arc(player.x, player.y, 20, 0, 7); ctx.fill();
            ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(player.x+player.facing.x*10, player.y+player.facing.y*10, 5, 0, 7); ctx.fill();

            // 투사체 (적 투사체는 빨간색 테두리)
            projectiles.forEach(p => { 
                ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,p.radius,0,7); ctx.fill(); 
                if(p.owner === 'enemy') { ctx.strokeStyle='red'; ctx.lineWidth=2; ctx.stroke(); }
            });

            particles.forEach(p => { ctx.fillStyle=p.color; ctx.globalAlpha=p.life/500; ctx.beginPath(); ctx.arc(p.x,p.y,3,0,7); ctx.fill(); ctx.globalAlpha=1; });

            document.getElementById('ui-hp').innerText = Math.floor(player.hp);
        }

        // --- 공격/피격 로직 ---
        function basicAttack() {
            const angle = Math.atan2(player.facing.y, player.facing.x);
            // 내 화면에 총알 생성 (주인: 나)
            createProjectile(player.x, player.y, angle, 'bullet', 'me', JOBS[player.job].damage);
            
            // 서버에 "나 쐈어"라고 알림
            if(game.mode === 'multi') {
                socket.emit('attack_event', { 
                    room: game.room, 
                    type: 'basic', 
                    x: player.x, 
                    y: player.y, 
                    angle: angle,
                    damage: JOBS[player.job].damage // 데미지 정보도 전송
                });
            }
        }

        // [중요] 상대 공격 신호 처리
        function handleOpponentAttack(data) {
            // 상대방 위치에서 총알 생성 (주인: 적)
            // type에 따라 스킬/평타 구분 가능하지만 일단 기본 평타처럼 처리
            if(data.type === 'basic') {
                createProjectile(data.x, data.y, data.angle, 'bullet', 'enemy', data.damage);
            }
            // 스킬 처리 로직도 여기에 추가 가능
        }

        function createProjectile(x, y, angle, type, owner, damage) {
            projectiles.push({ 
                x:x, y:y, 
                vx:Math.cos(angle)*10, vy:Math.sin(angle)*10, 
                life:1000, radius:5, color:'yellow', 
                owner: owner, // 'me' 또는 'enemy'
                damage: damage || 10 
            });
        }
        
        function createParticles(x, y, c, n) {
            for(let i=0;i<n;i++) particles.push({x:x, y:y, vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5, life:500, color:c});
        }

        function damagePlayer(amount) {
            player.hp -= amount;
            createParticles(player.x, player.y, 'red', 5);
            
            // 멀티플레이면 변경된 HP를 즉시 전송
            if(game.mode === 'multi') {
                socket.emit('player_update', {
                    room: game.room,
                    x: player.x,
                    y: player.y,
                    hp: player.hp,
                    facing: player.facing
                });
            }

            if(player.hp <= 0) {
                game.active = false;
                document.getElementById('game-over').style.display = 'flex';
                if(game.mode === 'multi') socket.disconnect();
            }
        }
        
        function useSkill(k) { /* 스킬 로직 생략 (기존과 동일하게 구현 후 owner='me'로 투사체 생성) */ }
    </script>